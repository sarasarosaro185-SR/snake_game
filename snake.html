<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Risk Snake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-red: #ff003c;
            --neon-blue: #00f3ff;
            --neon-green: #0aff00;
            --bg-dark: #050505;
            --grid-color: rgba(0, 243, 255, 0.1);
        }

        body {
            background-color: var(--bg-dark);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden; /* Prevent scrolling while playing */
            touch-action: none;
        }

        .font-cyber {
            font-family: 'Orbitron', sans-serif;
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }

        /* Background Grid Animation */
        .bg-grid {
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px;
            perspective: 500px;
            transform-style: preserve-3d;
            animation: moveGrid 20s linear infinite;
        }

        @keyframes moveGrid {
            0% { background-position: 0 0; }
            100% { background-position: 40px 40px; }
        }

        /* Neon Glow Utility */
        .text-glow-red { text-shadow: 0 0 10px var(--neon-red), 0 0 20px var(--neon-red); }
        .text-glow-blue { text-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue); }
        .box-glow-blue { box-shadow: 0 0 15px var(--neon-blue), inset 0 0 15px rgba(0, 243, 255, 0.2); }
        .box-glow-red { box-shadow: 0 0 15px var(--neon-red), inset 0 0 15px rgba(255, 0, 60, 0.2); }

        /* Game Canvas */
        canvas {
            background: rgba(10, 10, 16, 0.8);
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
            display: block;
        }

        /* Mobile Controls */
        .d-pad-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            active: background: var(--neon-blue);
        }
        .d-pad-btn:active {
            background: rgba(0, 243, 255, 0.3);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        /* Glitch Effect for Title */
        .glitch {
            position: relative;
        }
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .glitch::before {
            left: 2px;
            text-shadow: -1px 0 red;
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }
        .glitch::after {
            left: -2px;
            text-shadow: -1px 0 blue;
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim 2.5s infinite linear alternate-reverse;
        }
        @keyframes glitch-anim {
            0% { clip: rect(14px, 9999px, 127px, 0); }
            20% { clip: rect(8px, 9999px, 46px, 0); }
            40% { clip: rect(100px, 9999px, 11px, 0); }
            60% { clip: rect(62px, 9999px, 78px, 0); }
            80% { clip: rect(34px, 9999px, 16px, 0); }
            100% { clip: rect(98px, 9999px, 53px, 0); }
        }
        @keyframes glitch-anim-2 {
            0% { clip: rect(65px, 9999px, 100px, 0); }
            20% { clip: rect(12px, 9999px, 86px, 0); }
            40% { clip: rect(95px, 9999px, 21px, 0); }
            60% { clip: rect(32px, 9999px, 5px, 0); }
            80% { clip: rect(54px, 9999px, 106px, 0); }
            100% { clip: rect(23px, 9999px, 66px, 0); }
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative">

    <div class="scanlines"></div>
    <div class="absolute inset-0 bg-grid -z-10 opacity-30"></div>

    <!-- Header -->
    <header class="w-full max-w-2xl px-4 py-2 flex justify-between items-end z-10 mb-2">
        <div>
            <h1 class="font-cyber text-3xl md:text-5xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600 glitch" data-text="RISK SNAKE">
                RISK SNAKE
            </h1>
            <p class="text-xs text-cyan-300 opacity-70 tracking-widest uppercase">High Stakes. High Speed.</p>
        </div>
        <div class="text-right">
            <div class="text-xs text-gray-400 uppercase">Score</div>
            <div id="scoreDisplay" class="font-cyber text-2xl md:text-3xl text-white font-bold text-glow-blue">0</div>
            <div class="text-[10px] text-gray-500 mt-1">HIGH: <span id="highScoreDisplay">0</span></div>
        </div>
    </header>

    <!-- Game Container -->
    <div class="relative group">
        <!-- Canvas -->
        <canvas id="gameCanvas" width="400" height="400" class="rounded-lg max-w-[95vw] max-h-[60vh]"></canvas>

        <!-- Start/Pause Overlay -->
        <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 backdrop-blur-sm rounded-lg z-20 transition-opacity duration-300">
            <h2 class="font-cyber text-4xl text-white mb-2 text-glow-blue">READY?</h2>
            <p class="text-cyan-200 mb-6 text-sm md:text-base text-center px-4">Use Arrow Keys / Swipe to Move</p>
            <button id="startBtn" class="px-8 py-3 bg-cyan-500 hover:bg-cyan-400 text-black font-cyber font-bold rounded-sm box-glow-blue transform transition hover:scale-105">
                INITIALIZE
            </button>
        </div>

        <!-- Game Over Overlay -->
        <div id="gameOverScreen" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/90 backdrop-blur-md rounded-lg z-30">
            <h2 class="font-cyber text-4xl text-red-500 mb-2 text-glow-red glitch" data-text="TERMINATED">TERMINATED</h2>
            <p class="text-gray-300 mb-2">Final Score</p>
            <div id="finalScore" class="font-cyber text-5xl text-white mb-6">0</div>
            <button id="restartBtn" class="px-8 py-3 bg-red-600 hover:bg-red-500 text-white font-cyber font-bold rounded-sm box-glow-red transform transition hover:scale-105">
                RETRY
            </button>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div class="mt-6 w-full max-w-[300px] grid grid-cols-3 gap-2 md:hidden z-10 select-none">
        <div></div>
        <button id="btnUp" class="d-pad-btn h-14 rounded-lg flex items-center justify-center text-cyan-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" /></svg>
        </button>
        <div></div>
        
        <button id="btnLeft" class="d-pad-btn h-14 rounded-lg flex items-center justify-center text-cyan-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>
        </button>
        <button id="btnDown" class="d-pad-btn h-14 rounded-lg flex items-center justify-center text-cyan-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" /></svg>
        </button>
        <button id="btnRight" class="d-pad-btn h-14 rounded-lg flex items-center justify-center text-cyan-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>
        </button>
    </div>

    <!-- Instructions / Footer -->
    <div class="hidden md:block mt-6 text-xs text-gray-500 font-mono">
        [SPACE] to Pause &nbsp;|&nbsp; [ARROWS] to Move &nbsp;|&nbsp; [R] to Restart
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreDisplay');
        const highScoreEl = document.getElementById('highScoreDisplay');
        const finalScoreEl = document.getElementById('finalScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');

        // Game Configuration
        const TILE_SIZE = 20;
        let GRID_WIDTH = 20;
        let GRID_HEIGHT = 20;
        
        // Responsive Canvas
        function resizeCanvas() {
            const containerWidth = Math.min(window.innerWidth * 0.95, 600);
            // Snap to tile size
            const w = Math.floor(containerWidth / TILE_SIZE) * TILE_SIZE;
            const h = Math.min(Math.floor(window.innerHeight * 0.6 / TILE_SIZE) * TILE_SIZE, w); // Square-ish
            
            canvas.width = w;
            canvas.height = h;
            GRID_WIDTH = w / TILE_SIZE;
            GRID_HEIGHT = h / TILE_SIZE;
        }
        
        window.addEventListener('resize', () => {
            if (!gameRunning) resizeCanvas();
        });
        resizeCanvas();

        // Game State
        let snake = [];
        let food = {};
        let direction = 'right';
        let nextDirection = 'right';
        let score = 0;
        let highScore = localStorage.getItem('riskSnakeHighScore') || 0;
        let gameRunning = false;
        let gameSpeed = 100;
        let gameLoopId;
        let particles = [];
        let gameTime = 0;

        // Colors
        const COLORS = {
            snakeHead: '#00f3ff',
            snakeBody: '#00c2cc',
            food: '#ff003c',
            foodGlow: 'rgba(255, 0, 60, 0.6)',
            snakeGlow: 'rgba(0, 243, 255, 0.4)'
        };

        highScoreEl.innerText = highScore;

        // Sound Effects (Synthesized)
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'eat') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'die') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            }
        }

        // Particle System
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3 + 1;
                this.speedX = Math.random() * 4 - 2;
                this.speedY = Math.random() * 4 - 2;
                this.life = 1.0;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        // Core Functions
        function initGame() {
            snake = [
                {x: 5, y: 10},
                {x: 4, y: 10},
                {x: 3, y: 10}
            ];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            gameSpeed = 120; // Slower start
            scoreEl.innerText = score;
            placeFood();
            gameRunning = true;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameLoop();
        }

        function placeFood() {
            let valid = false;
            while (!valid) {
                food = {
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT)
                };
                valid = !snake.some(segment => segment.x === food.x && segment.y === food.y);
            }
        }

        function update() {
            direction = nextDirection;
            const head = { ...snake[0] };

            switch(direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            // Collision with Walls
            if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
                gameOver();
                return;
            }

            // Collision with Self
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            // Eat Food
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreEl.innerText = score;
                playSound('eat');
                createExplosion(head.x * TILE_SIZE + TILE_SIZE/2, head.y * TILE_SIZE + TILE_SIZE/2, COLORS.food);
                
                // Increase speed slightly (Risk mechanic)
                if (gameSpeed > 50) gameSpeed -= 2;
                
                placeFood();
            } else {
                snake.pop();
            }
        }

        function draw() {
            // Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Grid (Subtle)
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
            ctx.lineWidth = 1;
            for(let x=0; x<=canvas.width; x+=TILE_SIZE) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for(let y=0; y<=canvas.height; y+=TILE_SIZE) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }

            // Draw Food (Pulsing)
            const pulse = 1 + Math.sin(Date.now() / 200) * 0.2;
            const foodX = food.x * TILE_SIZE + TILE_SIZE/2;
            const foodY = food.y * TILE_SIZE + TILE_SIZE/2;
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = COLORS.food;
            ctx.fillStyle = COLORS.food;
            ctx.beginPath();
            ctx.arc(foodX, foodY, (TILE_SIZE/2 - 2) * pulse, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Snake
            ctx.shadowBlur = 10;
            ctx.shadowColor = COLORS.snakeHead;
            
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? COLORS.snakeHead : COLORS.snakeBody;
                
                // Gradient for body
                if(index > 0) {
                   ctx.globalAlpha = 1 - (index / (snake.length + 5));
                }

                ctx.fillRect(
                    segment.x * TILE_SIZE + 1, 
                    segment.y * TILE_SIZE + 1, 
                    TILE_SIZE - 2, 
                    TILE_SIZE - 2
                );
                
                ctx.globalAlpha = 1;
            });
            ctx.shadowBlur = 0;

            // Draw Particles
            particles.forEach((p, index) => {
                p.update();
                p.draw(ctx);
                if(p.life <= 0) particles.splice(index, 1);
            });
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            setTimeout(() => {
                requestAnimationFrame(gameLoop);
            }, gameSpeed);

            update();
            draw();
        }
        
        // Separate loop for smooth particles regardless of game speed
        function animationLoop() {
            if(!gameRunning && particles.length > 0) {
                 // Clear just to draw particles if game over but particles remain
                 // Actually better to handle inside gameLoop or shared render loop.
                 // For simplicity, particles render in the main draw().
            }
            if(gameRunning) {
               // Used for high framerate effects if separated from logic tick
            }
            requestAnimationFrame(animationLoop);
        }
        // requestAnimationFrame(animationLoop); // Not strictly needed for this simple version

        function gameOver() {
            gameRunning = false;
            playSound('die');
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('riskSnakeHighScore', highScore);
                highScoreEl.innerText = highScore;
            }
            
            finalScoreEl.innerText = score;
            gameOverScreen.classList.remove('hidden');
        }

        // Controls
        function handleInput(key) {
            if (!gameRunning) return;
            
            switch(key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction !== 'down') nextDirection = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction !== 'up') nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction !== 'right') nextDirection = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction !== 'left') nextDirection = 'right';
                    break;
            }
        }

        document.addEventListener('keydown', (e) => {
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            handleInput(e.key);
            
            // Restart on R
            if ((e.key === 'r' || e.key === 'R') && !gameRunning) {
                initGame();
            }
            // Start on Space if not running
            if (e.key === ' ' && !gameRunning && gameOverScreen.classList.contains('hidden')) {
                initGame();
            }
        });

        // Touch/Click Handlers
        startBtn.addEventListener('click', () => {
             // Audio context must be resumed on user gesture
            if (audioCtx.state === 'suspended') audioCtx.resume();
            initGame();
        });
        
        restartBtn.addEventListener('click', () => {
            initGame();
        });

        // Mobile D-Pad
        document.getElementById('btnUp').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowUp'); });
        document.getElementById('btnDown').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowDown'); });
        document.getElementById('btnLeft').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowLeft'); });
        document.getElementById('btnRight').addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowRight'); });
        
        // Mouse clicks for D-pad (testing on desktop)
        document.getElementById('btnUp').addEventListener('mousedown', (e) => { e.preventDefault(); handleInput('ArrowUp'); });
        document.getElementById('btnDown').addEventListener('mousedown', (e) => { e.preventDefault(); handleInput('ArrowDown'); });
        document.getElementById('btnLeft').addEventListener('mousedown', (e) => { e.preventDefault(); handleInput('ArrowLeft'); });
        document.getElementById('btnRight').addEventListener('mousedown', (e) => { e.preventDefault(); handleInput('ArrowRight'); });

        // Swipe Handling
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', function(evt) {
            touchStartX = evt.touches[0].clientX;
            touchStartY = evt.touches[0].clientY;
        }, false);

        document.addEventListener('touchmove', function(evt) {
            if(!gameRunning) return;
            // Prevent scrolling
            evt.preventDefault();
        }, { passive: false });

        document.addEventListener('touchend', function(evt) {
            if(!gameRunning) return;
            
            let touchEndX = evt.changedTouches[0].clientX;
            let touchEndY = evt.changedTouches[0].clientY;
            
            let dx = touchEndX - touchStartX;
            let dy = touchEndY - touchStartY;
            
            if(Math.abs(dx) > Math.abs(dy)) {
                if(Math.abs(dx) > 30) { // Threshold
                    if(dx > 0) handleInput('ArrowRight');
                    else handleInput('ArrowLeft');
                }
            } else {
                if(Math.abs(dy) > 30) {
                    if(dy > 0) handleInput('ArrowDown');
                    else handleInput('ArrowUp');
                }
            }
        }, false);

        // Initial Draw
        resizeCanvas();
        
    </script>
</body>
</html>